# Plan: Aspire orchestration for Scenario 6 (frontend + moshi backend)

## Goal
Use .NET Aspire to launch Scenario 6 with separate frontend and backend services, and vendor the moshi backend code into the repo (no GitHub dependency) with a clear update path.

## Context
- Scenario 6 currently runs a FastAPI app that serves the UI and launches moshi as a subprocess.
- The request is to orchestrate frontend + backend with Aspire and include moshi code locally.

## Assumptions
- We will keep Scenario 6 as the feature owner and place Aspire assets under scenario6/.
- Container-based orchestration is acceptable (consistent with scenario4 usage).
- The moshi server can run as a standalone Python entrypoint (e.g., `python -m moshi.server`).

## Plan (Phased)

### Phase 1: Aspire baseline (frontend + moshi services)
1) **Confirm desired service split**
   - Frontend: static UI (today served by FastAPI). Decide whether to keep FastAPI for config/logs or move to a standalone static web server.
   - Backend: moshi server as its own process with HTTPS/WSS.
   - Frontend must not launch or manage moshi; it only consumes Aspire-provided endpoint info.
   - Decide if FastAPI remains as a lightweight “config API only” or is removed in favor of static hosting.

2) **Define Aspire topology**
   - Create a new AppHost for Scenario 6 (e.g., scenario6/AppHost) similar to scenario4.
   - Add two services:
     - `scenario6-frontend` (UI + optional config API).
     - `scenario6-moshi` (backend speech-to-speech).
   - Define environment variables for ports, model paths, HF cache, and tokens.
   - Add persistent volume for Hugging Face cache to avoid re-downloads.

3) **Wire services together**
   - Frontend reads moshi endpoint/port from Aspire service bindings and never starts moshi itself.
   - Frontend config API (if kept) should expose the resolved `moshi` endpoint info to the UI.
   - Add a minimal service discovery contract (`/health`, `/api/info`) so the UI can verify backend version/status.
   - Ensure HTTPS cert handling for moshi is compatible with local dev (self-signed).
   - Define a health endpoint for moshi to let Aspire surface status.

### Phase 2: Containerization and environment alignment
4) **Containerize services**
   - Add Dockerfile(s) under scenario6/ to run each service:
     - Frontend container: serve static UI and/or FastAPI app.
     - Moshi container: run `python -m moshi.server` from vendored code.
   - Ensure GPU passthrough (if available) and CPU fallback is documented.

5) **Environment requirements (Aspire-aligned)**
   - Capture the non-standard env requirements from current setup:
     - Python 3.10–3.12 only (3.12 recommended), Python 3.13 unsupported.
     - PyTorch must be installed from CUDA index URL (cu121).
     - Moshi package install (currently via Git clone) and Opus system dependency.
     - HF token, license acceptance, and large model cache location.
   - Adapt the install flow so Aspire users follow the same constraints:
     - Container images use a pinned Python version and CUDA base image.
     - Document how CUDA libraries/drivers are validated on host.
     - Document how the HF cache volume is created and reused.
     - Provide a "no GPU" fallback path and explain CPU offload limits.

### Phase 3: Vendor moshi and update flow
6) **Vendor moshi code (no GitHub dependency)**
   - Add a `scenario6/third_party/moshi/` directory containing the moshi package source.
   - Record upstream version/commit in a `MOSHI_VERSION` file.
   - Update `requirements.txt` to use local path dependency (e.g., `-e ./third_party/moshi`), or package it as a local module.
   - Ensure licensing is preserved (include upstream LICENSE in third_party).

7) **Define update strategy for vendored moshi**
   - Provide a script (e.g., `tools/update_moshi.ps1` + `.sh`) that:
     - Downloads a tagged release tarball or shallow clone,
     - Copies `moshi/` package files into `scenario6/third_party/moshi`,
     - Updates `MOSHI_VERSION` and any patches.
   - Document the update steps in scenario6/docs/ (manual but repeatable).
   - Add a rollback strategy for vendored moshi updates (keep previous snapshot or tagged copies).

### Phase 4: Docs, onboarding, and observability
8) **Docs & developer workflow**
   - Add Scenario 6 Aspire instructions in scenario6/README.md:
     - `cd scenario6/AppHost && aspire run` to launch both services.
     - How to accept the moshi HTTPS cert.
   - Document environment variables and cache volumes.
   - Generate or update Scenario 6 documentation for install/setup, architecture, and troubleshooting.
   - Add a "1-command quickstart" path with expected first-run timings and model download size.
   - Add a preflight checklist (GPU driver + CUDA, Python version, HF token, license acceptance, disk space).
   - Add a first-run verification flow (open UI, accept cert, connect, speak, confirm audio output).
   - Provide a minimal troubleshooting table for common beginner blockers (cert, token, model access, CUDA, ports).
   - Document how to override ports and hostnames (VPN/proxy friendly).

9) **Observability and runtime options**
   - Wire logs/metrics into Aspire dashboard (OpenTelemetry optional but planned).
   - Define GPU/CPU selection via env flags and document expected behavior in Aspire.

## Out of Scope (for this plan)
- Implementing the Aspire AppHost or Dockerfiles.
- Making code changes to Scenario 6.
- Azure deployment specifics.
